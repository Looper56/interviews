# Redis

### redis基本的5种数据结构：string/list/set/hash/zset
#### string：动态字符串
##### 定义SDS对象：len buf已经占有长度，free buf中未使用的缓冲区长度，buf[]实际保存字符串的地方，去字符串的长度的时间复杂度为O(1)
##### 特性：降低分配次数提高追加速度，代价就是多占用一些内存空间，且不会自动释放，二进制安全，高效计算长度，高效追加字符串操作
#### list：可以拥有相同字符串，插入和删除非常快，时间复杂度为O(1),但索引定位很慢，时间复杂度为O(n),列表弹出最后一个元素后，该数据结构自动被删除
##### 列表对象保存的所有字符串元素长度小于64字节，对象数量小于512个，不满足时转码使用linkdlist，满足时使用ziplist
#### hash：无需字典，数组+链表的二维结构，第一维hash的数组位置碰撞时，会将碰撞的多元素使用链表串起来
##### ziplist转换阀值，键的个数小于512，所有值小于64，另一种hashtable。消耗较多内存空间
#### set：内部键值对是无序的唯一的，所有的value都是一只null，弹出最后一个元素后，该数据结构自动被删除
##### 通过散列表保证每个字符串各不相同，是无序的，inset时用于存储整数集合
#### zset：一方面是set，保证内部value的唯一性，另一方面给每一个score，代表value的权重
##### 和散列一样，存储键值对，有序集合的值被称为分值，必须为浮点数，是redis唯一一个既可以访问元素，又可以根据分值排序访问元素结构

### 为什么redis能够快速执行
#### 绝大部分请求是纯粹的内存操作，采用单线程，避免不必要上下文切换和竞争条件，非阻塞IO-IO多路复用

### redis持久化
#### RDB持久化
##### 通过创建快照(压缩二进制文件)的方式，保存某个时间点的全量数据，RDB是默认的持久化方式，手动触发，自动触发
##### RDB文件紧凑，体积小，网络传输快，适合全量复制，恢复速度比AOF快，RDB致命缺点数据快照的持久化方式必然不能实时持久化，因此AOF成为主流
#### AOF持久化
##### 即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中，服务器启动可以载入和执行AOF文件中
##### 优点在于秒级持久化，兼容性好，缺点文件大，恢复速度慢，性能影响大
#### RDB，AOF混合持久化
##### 首先RDB定期完成内存快照备份，再由AOF完成两次RDB之间的数据备份，充分利用RDB加载快，备份文件小，以及AOF尽不可能丢失数据的特性，缺点兼容性差

### redis持久化方案
#### 如果只是用来做缓存服务器，比如数据库查询等，不考虑持久化，提供很高的数据保障，建议同时使用两种持久化方式

### 缓存穿透，缓存击穿，缓存雪崩
#### 缓存穿透
##### 查询一个不存在的数据，如果从存储层查不到则不写入缓存，导致每次请求都到DB查询，可能导致DB挂掉
##### 解决方案：查询返回数据为空，也进行缓存，设置短的过期时间；布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，不存在的数据会被拦截
#### 缓存击穿
##### 对于设置过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对key有大量并发请求，请求会从DB加载并返回，并发可能瞬间压垮DB
##### 解决方案：使用互斥锁，当缓存失效时，不立即去load db，使用redis的setnx去设置一个互斥锁，当操作成功返回时再进行load db操作并回设缓存；永远不过期，物理不过期，逻辑过期
#### 缓存雪崩
##### 设置缓存采用相同的过期时间，导致缓存某一刻同时失效，请求全部转发到DB，DB瞬间压力过重，与缓存击穿的区别：雪崩多个key，击穿某一个key缓存
##### 解决方案：将缓存失效时间分散开，每个过期时间重复率降低

### redis集群模式
#### 主从复制
##### 当从数据库启动时，回向主数据库发送sync命令，主数据库收到sync后开始保存快照RDB，当快照完成时将快照和缓存命令发送给从，复制结束后，主每次收到命令就同步给从
##### 主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，异步把命令发送给从，不影响性能，也可以设置至少同步给多少个主从可写

### 哨兵模式
#### 作用：监控redis主，从数据库是否正常运行，主出现故障，将自动切换从数据库为主数据库
#### 核心：哨兵至少需要3个实例，保证健壮；哨兵+redis主从的部署结构，不保证零丢失，保证redis集群高可用；尽量在测试环境生产环境演练；监控系统时，只需配置监控主数据库即可，自动发现所有复制该主数据库的从数据库

### redis分布锁
#### 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间，防止忘记锁忘记释放，如果在setnx之后expire之前进程意外crash或者重启维护，这个锁就永远不得释放
#### 红锁
##### 用redis中的多个master实例，来获取锁，只有大多数实例获取到了锁，才算获取成功
##### 1.获取当前毫秒级时间
##### 2.使用相同key和随机值在N个节点上请求锁，获取锁的尝试时间小于锁超时时间，防止masterDown
##### 3.只有在大多数节点上获取锁，总的获取时间小于超时时间，认为获取成功
##### 4.如果锁获取成功，锁超时时间就是最初锁超时时间进去获取锁的总耗时间
##### 5.如果锁获取失败，都会将已经设置key的master上的key删除

### 内存淘汰机制
#### noeviction：当内存不足以容纳新写入数据时，新写入的操作就会报错
#### allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key
#### allkeys-randodm：当内存不足以新写入数据时，在键空间中，随机移除某个key
#### volatile-lru：当内存不足以新写入数据时，在设置过期时间的键空间中，移除最近最少使用的key
#### volatile-random：当内存不足以新写入数据时，在设置过期时间的键空间中，随机移除某个key
#### volatile-ttl：当内存不足以新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

### 过期策略
#### 设置过期之后的key该如何进行删除：定期删除+惰性删除
#### 定期删除：redis默认每隔100ms就随机抽取一些设置过期时间的key，检查其是否过期，进行删除，如果没有定期删除没有删除key，就需要惰性删除
#### 惰性删除：在获取某个key时，redis会检查一下，key是否设置过期时间，是否过期，就会删除，不返回任何东西
#### 定期删除，惰性删除也会落下很多，如果大量过期key堆积在内存中，就需要走淘汰机制

### redis和mysql的数据不一致怎么办
#### 采用双延时策略：第二个删除缓存redis，还没来得及写入DB，另一个线程来读，发现缓存为空，就去数据库中读取数据写入缓存，此时缓存为脏数据
#### 第一个删除redis，如果先写了库，在删除缓存前，写库的线程宕机了，没有删除缓存，也会出现数据不一致问题
#### 策略：先淘汰缓存，再写入数据库，休眠800ms，再次淘汰缓存，这样可以将800ms内所有造成的缓存脏数据再次删除

### redis常见性能问题和解决方案
#### Master最好不要做任何持久化工作(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，快照比较大时，对性能影响较大，会间断性暂停服务)
#### 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
#### 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
#### 尽量避免在压力很大的主库上增加从库

### mysql里有2000w数据，redis中只存了20w数据，如何保证redis中的是热点数据
#### volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
#### volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
#### volatile-random：从已设置过期时间的数据集中挑选任意数据淘汰
#### allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
#### allkeys-random：从数据集中任意挑选数据淘汰
#### no-enviction：禁止驱逐数据
#### 6中机制：volatile和allkeys规定是对已设置过期时间的数据集淘汰还是从全部数据集淘汰，后面的lru，ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收机制

### redis里面有一亿个key，其中10w个key是以某个固定的已知前缀开头的，如何将他们全部找出来
#### 使用keys指令可以扫出制定模式的key列表
### 如果redis正在给线上使用，那使用keys命令会有什么问题？
#### redis是单线程的，keys命令会导致线程阻塞一段时间，线上服务会停顿；这时候可以使用scan指令，scan可以无阻塞的提取出指定模式的key列表，但有一定几率重复，需要去重

### 项目中有没有用redis事务
#### 采用redis cluster集群架构，不同的key是有可能分配在不同的redis节点上的，这种情况redis事务机制不生效，其次redis事务不支持回滚操作，基本不用
