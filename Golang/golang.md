# Golang Basics

### Channel底层实现
#### channel是什么？
##### “不要通过共享内存通信，通过通信来共享内存”，经典go并发哲学
##### go的并发主要通过goroutine实现，而channel则像一个管道一样，实现goroutine之间的通信，虽然可以通过锁，原子操作能够实现数据的同步，但使用channel更优雅
#### channel的创建
##### 根据channel的size分为无缓冲和有缓冲的channel
##### 根据channel的发送和接收能力分为三种类型
##### make函数最终调用/go/src/runtime/chan.go 的makechan方法，主要进行chan的初始化和内存分配
#### channel的发送
##### channel的发送只是编译器的语法糖，实际调用runtime.chansend函数
#### channel的接收
##### channel的接收两种方式，最终调用runtime.chanrecv1和runtime.chanrecv2，而最终调用runtime.chanrecv

### golang内存逃逸：程序变量会携带一组校验数据，证明它的整个生命周期是否在运行时完全可知，通过校验就可以在 栈 分配，否则就说它逃逸，必须在 堆 上分配
### 通过 go build -gcflags=-m 查看逃逸情况
#### 方法内把局部变量指针返回：局部变量本应在栈中分配，栈中回收，返回时被外部引用，生命周期大于栈，溢出
#### 发送指针或带有指针的值到channel：不知道哪个goroutine会在channel接收数据，编译器不知道变量什么时候会被释放
#### 切片存储指针或带指针的值：典型例子 []*string 尽管后面的数组可能是在 栈 上分配，但引用的值一定是在 堆 上
#### slice的背后数组被重新分配了，因为append时可能会超出其容量cap，slice初始化的地方在编译时会在 栈 上分配，扩充会在 堆 上分配
#### interface类型上调用方法，interface类型上调用方法都是动态调用的，方法实现在运行的时候才知道，io.Reader类型的变量r，存储上逃逸，堆 上分配

### golang除了加Mutex锁以外还有哪些方式安全读写共享变量
#### goroutine可以通过channel进行安全读写共享变量

### 无缓冲chan发送和接收是否同步
#### ch := make(chan int) 无缓冲的channel由于没有缓冲发送和接收需要同步
#### ch := make(chan int， 2) 有缓冲的channel不要求缓冲发送和接收同步

### go的并发机制以及所使用的CSP并发模型
#### 以通信的方式来共享内存（独立的并发体通过共享的通讯channel进行通信），CSP中channel是第一类对象，它不关注发消息的实体，而关注与发消息时使用的channel
#### channel是被单独创建并且在进程之间传递，通信模式类似于boss-worker，一个实体将消息发送到channel中，又监听这个channel的实体处理，实体之间是匿名的，实体之间的解耦，channel是同步的一个消息发送到channel，最终一定要被另一个实体消费掉，原理类似一个堵塞的消息队列
#### Goroutine是go实际并发执行的实体，底层使用coroutine实现并发，是一种运行在用户态的用户线程，类似greenthread
#### Goroutine特点：
##### 用户空间避免内核态和用户态的切换导致的成本
##### 可以由语言和框架层进行调度
##### 更小的栈空间允许创建大量的实例
#### Goroutine特性：
##### 内部有三个对象：P对象（上下文，cpu），M（work thread）代表工作线程，G对象（goroutine），正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象，碰到goroutine对象阻塞时，会启动一个新的工作线程，以充分利用cpu对象

### go中常用的并发模型
#### 通过channel通知实现并发控制
##### 无缓冲的通道指的是通道的大小为0，要求发送goroutine和接收goroutine同时准备好，才可以完成发送接收操作，同步通道
#### 通过sync包中的WaitGroup实现并发控制
##### Goroutine时异步，为了防止在结束main函数结束Goroutine，所以需要同步等待，这个时候就需要WaitGroup，会收集所有goroutine任务全部完成，主要三个方法：
##### Add，可以减少或添加goroutine的数量
##### Done，相当于Add（-1）
##### Wait，执行后会堵塞主线程，知道WaitGroup里值减至0
#### 1.17后引进的Context
##### context主要用来处理多个goroutine之间共享数据，及多个goroutine的管理
##### context包的核心时struct Context
##### Done（）返回一个只能接收数据的channel类型，当该context关闭或者超时，channel会有一个取消信号
##### Err（）在Done（）之后，返回context取消的原因
##### Deadline（）设置改context cancel的时间点
##### Value（）方法允许Context对象携带的request作用域的数据，该数据必须是线程安全的
##### Context对象是线程安全的，你可以把一个Context对象传递给任意个数的goroutine，对它执行取消操作时，所有的goroutine都会接收到取消的信号
##### 一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据接收取消信号和发送信号的函数通常不是一个，父操作为子操作启动goroutine，子操作不能取消父操作

### JSON标准库对nil slice 和 空 slice的处理是一致的吗
#### var slice []int slice[1] = 0 只声明slice，没有实例化对象
#### slice := make([]int,0) slice := []int{} 此时slice的值是nil，这种情况可以用于需要返回的slice函数，保证函数返回会有nil的返回值
#### empty slice 是指slice不为nil，但是slice没有值，slice底层空间是空的

### 协程，线程，进程的区别
#### 进程是具有一个独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位，每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信，由于进程比较重量，独占据内存内存，所以上下文间的切换开销比较大，但相对比较稳定安全
#### 线程是进程的一个实体，是CPU调度和分派的基本单位，比进程更小的的能够独立运行的基本单位，自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（计数器，寄存器和栈），但是它可与同属一个进程的其他线程共享进程所拥有的全部资源，线程间通信主要通过共享内存，上下文切换快，资源开销少，不稳定易丢失数据
#### 协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程拥有自己的寄存器和上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁访问全局变量，上下文切换非常快

### 协程和线程区别(深)
#### 一个线程可以多个协程，一个进程可以单独拥有多个协程
#### 线程进程都是同步机制，而协程是异步
#### 协程能够保存上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态
#### 线程是抢占式，而协程是非抢占式，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力
#### 协程并不是取代线程，而是抽象于线程之上，线程是被分割的CPU资源，协程是组织好的代码流程，协程需要线程来承载运行，线程是协程的多资源，但协程不会直接使用线程，协程直接利用的是执行器，执行器可以关联任意线程或线程池，可以使当前线程，UI线程，或新建线程
#### 线程是协程的资源，协程通过interceptor间接使用这个资源

### 协程比线程轻量级分析
#### 一旦创建完线程，就无法决定它们什么时候获得时间片，什么时候 让出时间片，这里都交给内核，和我们编写协程时可以控制，可控切换时机和很小的切换代价，从操作系统有没有调度权来看，协程就是因为不需要进行内核态的切换
#### Go协程调用跟切换比线程效率高，线程并发执行流程：
##### 线程是内核对外提供服务，应用程序可以通过系统调用让内核启动线程，由内核负责线程调度和切换，线程在等待IO操作时标为unrunnable状态触发上下文切换，现代操作系统一般采取抢占式调度，上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如需要切换就从运行队列中选出一个线程目标，保存当前线程的环境，并且恢复目标线程的运行环境，最经典的就是切换ESP指向目标线程内核堆栈，将EIP指向目标线程上次被调度出时的指令地址
##### Go协程并发执行流程：
##### 不依赖操作系统和其提供的线程，Go自己实现CSP并发模型：M，P，G
##### Go协程也叫用户态线程，协程之间的切换发生在用户态，在用户态没有时钟中断，系统调用等机制，因此效率高
##### Go协程占用内存小：
##### 执行Go协程只需要极少的栈内存，默认情况下，线程栈的大小为1MB
##### Goroutine就是一段代码，函数入口，以及在堆上为其分配一个堆栈，所以它非常廉价，就可以轻松创建上万个Goroutine，但它们并不是被操作系统所调度执行

### 互斥锁，读写锁，死锁问题
#### 互斥锁
##### 互斥锁就是互斥变量mutex，用来锁住临界区的
##### 条件锁就是条件变量，当进程的某些资源要求不满足时就进去休眠，也就是锁住，当资源被分配到了，条件锁打开，进程继续运行，读写锁，用于缓冲区等临界资源能互斥访问
#### 读写锁
##### 通常有些公共数据修改的机会很少，但其读的机会很多，在读的过程中会伴随着查找，加锁降低我们效率，读写锁可以解决这个问题（写独占，读共享，写锁优先级高）
#### 死锁
##### 互斥条件：一个资源每次只能被一个进程使用
##### 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放
##### 不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺
##### 循环等待，若干进程头尾相接循环等待
#### 预防死锁
##### 可以把资源一次性分配；当某进程新的资源未满足时，释放己占有的资源；系统赋予每类资源一个编号，每一个进程按编号递增的顺序请求资源，释放相反
#### 避免死锁
##### 施加较弱的限制，从而获得较满意的系统性能，避免死锁的策略中，允许进程动态申请资源，系统在资源分配之前预先计算资源分配的安全性，若此次不会导致系统不安全，则资源分配给进程，否则进程等待
#### 检测死锁
##### 首先为每个进程和每个资源指定一个唯一的号码，然后建立资源分配表和进程等待表
#### 解除死锁
##### 当发现有进程死锁后，便应立即把它从死锁状态解脱出来：剥夺资源、撤销进程

### go内存模型，小对象多了会造成gc压力
#### 通常小对象过多会导致GC三色消耗过多GPU，减少对象分配

### Data Race问题：
#### 同步访问共享数据是处理数据竞争的一种有效方法，可以使用go run -race/go build -race来进行静态检测

### 什么是channel，为什么可以线程安全
#### channel是Go的核心类型，通过它并发核心单元可以发送或者接收数据进行通讯，可以是先进先出的队列，通过管道进行通信

### 并发编程的概念：
#### 并行是在不同实体上的多个事件，并发是在同一实体的多个事件，同时处理多个任务
#### 并发偏重于多个任务交替执行，而多个任务之间有可能还是串行

### 负载均衡原理：
#### 通常是分摊到多个操作单元上进行执行，例如web服务器，FTP服务器，企业关键应用服务器和其他关键任务服务器，从而共同完成工作任务
#### 负载均衡器一般根据两个因素决定要将请求转发到哪个服务器，确保服务器能够对请求做出响应，根据预先设置的规则从健康服务器（healthy pool）池中进行选择
#### 允许状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器，服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发，直至再次通过检查
#### 负载均衡算法：
##### Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后再按顺序向下移动至结尾，然后循环
##### Least Connections （最小连接）：优先选择连接数最少的服务器，在普通会话较长的情况推荐使用
##### Source：根据请求源IP的散列（hash）选择要转发的服务器，可以一定程度保证特定用户能连接到相同的服务器（基于IP信息创建关联，或使用sticky sessions）
#### 负载均衡解决单机故障问题，可以将第二个负载均衡连接到第一个上，从而形成一个集群

### new和make的区别
#### new的作用初始化一个指向类型的指针（*T），函数定义：func new(Type) *Type,new分配空间，传递给new的是一个类型，不是指，返回值是指向这个新分配的零值的指针
#### make的作用是为slice，map，chan初始化并返回引用（T）
#### make函数是内建函数，函数定义：func make(Type,size IntegerType) Type,返回类型是T（不是T*）的初始化的（不是零值）实例

### Printf()/Sprintf()/Fprintf()函数的区别用法是什么
#### 都是把格式化好的字符串输出，输出目标不一样
#### Printf()，是把字符串输出到标准输出，是和stdout关联的，Fprintf没有这个限制
#### Sprintf(),是把格式字符串输出到指定的字符串中，所以参数比Printf多一个chan*，目标字符串地址
#### Fprintf()，把格式字符串输出到指定文件设备中，所以参数比printf多一个文件指针FILE*,用于文件操作

### 数组和切片的区别
#### 数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列，数组长度是数组类型的一部分，所以[3]int和[4]int是两种不同类型，数组是值传递，长度无法改变
#### 切片标识拥有一个相同类型元素的可变长度的序列，切片是一种轻量级的数据结构，属性：指针、长度、容量
#### 切片是地址传递，切片可以通过数组来初始化，也可以通过内置函数make()初始化，初始化时len=cap，在追加元素时如果容量cap不足时将按len的2倍扩容

### go协程
#### 协程和线程都可以实现程序的并发执行，通过channel来进行协程间的通信，关键字 go 并非执行并发任务，而是创建一个并发任务单元

### for循环
#### for循环支持continue和break来控制循环，但是它提供一个更高级的break，可以选择中断哪一个for循环，必须使用平行赋值方式初始化多个变量

### switch语句
#### 只要在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case

### go语言中没有隐藏的this指针？
#### 方法施加的对象显式传递，没有被隐藏，面向对象表达更加直观，方法施加的对象不需要非得是指针，也不用非得是this

### go语言的引用类型包含哪些
#### 数组切片，map，channel，interface

### 指针运算有哪些
#### “&” 取指针的地址  “*”取指针指向的数据

### go main()函数
#### main()函数不能带参数，不能定义返回值，所在包必须为main包，可以使用flag包获取和解析命令行函数

### go同步锁
#### 当一个goroutine获得了Mutex后，其他goroutine只能等待,除非goroutine释放这个Mutex
#### RWMutex在读锁占用情况下，会阻止写，但不阻止读，在写锁占用的情况下，会阻止其他goroutine，整个锁相当于改goroutine独占

### channel特性
#### 给一个nil channel发送/接收数据，永远阻塞，给一个已经关闭的channel发送数据，引起panic，给一个已经关闭的channel接收数据，如果缓存区为空，则返回一个零值
#### 无缓存区的channel是同步的，而有缓存的channel是非同步的
#### 空(nil)读写阻塞，写关闭异常，读关闭空零

### go触发异常场景
#### 空指针解析、下标越界、除数为0、调用panic函数

### go的select机制
#### select机制用来处理异步IO问题
#### select机制最大的一条限制就是每个case语句必须是一个IO操作

### 结构体的比较问题
#### 只有相同的结构体才可以比较，及时结构体属性类型相同，但是里面存在不可比较的类型，依然不可以直接==比较，如map、slice 可以参考reflect.DeepEqual方法比较

### string与nil类型的问题
#### nil空值的赋值，空指针，所有的引用类型都可以用nil赋值：interface、function、pointer、map、slice、channel
#### 表示string的空值，用""表示，不能将nil赋值给string类型

### 常量的问题
#### 数据类型的本质 固定内存大小的别名
#### 数据类型的作用 编译器预算对象或变量分配内存空间的大小
#### 内存四区：
##### 栈区：空间较小，要求数据读写性能高，数据存放时间比较短暂，由编译器自动分配和释放，存放函数的参数值，函数调用流程方法地址，局部变量等（局部变量产生内存逃逸，挂在堆）
##### 堆取：空间充裕，数据存放比较久，一般由发开着分配及释放（Go会根据变量的逃逸现象选择是否分配在栈、堆），启动GC清除机制自动回收
##### 全局区：静态全局变量区，在main之前就已经放在内存中，作用域全部代码，常量区也归属全局区
##### 代码区：存放代码逻辑的内存

### 数组与切片
#### 切片初始化和追加：切片经过make初始化，默认数据的值是0，append是动态额外开辟内存
#### slice拼接问题：两个slice在append的时候需要对第二个slice进行...打散拼接，s1 = append(s1,s2...)
#### slice中new的使用问题：make只用于slice、map、channel的初始化（非零值），返回还是这三个引用类型本身，而new用于类型的内存分配，并且内存内置为零，new返回的是指向类型指针

### slice结构
#### slice是Go中的一种基本的数据结构，动态数组，常见操作reslice/append/copy，切片具有可索引，可迭代的优秀特性
#### 切片数组怎么选择
##### Go数组是值类型，赋值和函数传参都会复制整个数组数据，导致大量内存消耗，通过数组指针传递，性能更优，假如原数组的指针指向改变，函数的指针也会跟着改变
##### 切片的优势：切片传数组参数，可以节约内存，切片的指针和原来数组的指针式不同的
#### 切片的数据结构
##### 切片本身是动态数组或者数组指针，通过指针引用底层数组，切片是对数组的一个连续片段的引用，是一个引用类型，给定项切片索引可能比相关数组相同元素索引小，运行时可改变长度，长度可变的数组
##### type slice struct {array unsafe.Pointer len int cap int}
##### slice copy：copy的长度时src或dst中len最少的那个，copy返回值时实际拷贝的元素数量，支持原地拷贝，避免原地址拷贝过程中元素覆盖的问题
##### slice append：方法提供可变参数，允许向一个slice上append另一个slice，批量append，当且仅当append的数量+当前长度>cap时，cap和pointer就会被修改，当s的len小于cap时，append的操作也会影响其他slice


### string的拼接
#### ”“ + ”“ ,go的字符串是不可变的类型，通过+连接会产生一个新的字符串对效率又影响
#### sprintf，也会产生临时字符串，效率不高
#### strings包的Join函数，申请拼接后大小内存，依次填入，在已有的数组情况下，效率会很高
#### buffer.WriteString函数，性能最优
#### buffer.Builder 同上，官方不建议

### Map
#### map的value赋值：定义map推荐map[string]Student map的value student属性不可修改，推荐：map[string]*Student,value可修改
#### map遍历问题：
##### 不推荐将数组依次添加到map for _, stu := range stus{m[stu.Name]=&stu}
##### 推荐遍历整个slice数组，一次赋值给map for i:=0;i<len(stus);i++{m[stus[i].Name] = &stu[i]}

### interface
#### interface赋值：
##### 多态的三要素：有interface接口，并且有定义接口方法；有子类去重写interface接口；有父类指针指向子类的具体对象。如果People是一个interface类型 var peo people = Student{} (错误) var peo people = &Student{} （正确） 
##### interface{} 和 *interface{}：如果 *interface{}作为形参，那么只能接收 *interface{}类型的实参

### go的init函数
#### 一个包可以包含多个init函数，程序编译时，先执行导入包的init函数，再执行本包内的init函数
#### func s() int { return 1 } var _ = s() 优先init()执行

### Log包线程安全
#### log机制，在输出位置做了线程安全保护

### 主协程如何等待其余协程完再操作
#### 使用channel进行通信，context，select

### go常见问题 （https://www.zhihu.com/question/60952598）（https://geektutu.com/post/qa-golang.html）
#### uint不能直接相减，结果是负数会变成很大的uint
#### channel需要进行close
#### goroutine需要return或者中断，容易造成goroutine占用大量CPU
#### 从slice创建slice时候，注意原slice操作可能导致底层数组变化
#### 创建很长的slice时，尽量创建成一个slice里存引用，可以分批释放，避免gc stop the world
#### channel是通过goroutine id实现消息通知的
#### 空struct{}会在什么情况下使用：var ch chan struct{}
#### “var”与“:=”有什么区别：var全局变量，:= 只能作用域函数内部
#### go拷贝map：浅：新建遍历赋值，深：json序列化反序列化生成新的map，或者代码递归
#### 2 个 nil 可能不相等吗？ interface被确定的赋值，才会相等
#### 简述GC回收机制：https://www.jianshu.com/p/083ec45b693d
#### 函数返回局部变量的指针是否安全？：是的，它是安全的，因为围棋编译器执行逃逸分析和堆分配这些变量。