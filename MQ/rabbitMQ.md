# rabbitMQ

### rabbimtMQ是什么
#### 实现高级消息队列协议(AMQP)面向消息中间件，集群和故障转移是构建在开发电信平台框架上，均有代理接口通讯的客户端库

### rabbitMQ特点
#### 可靠性：使用一些机制保证可靠性，持久化，传输确认及发布确认等
#### 灵活的路由：消息进入队列前，通过交换机绑定路由，针对复杂路由，将多个交换机绑定在一起，也可以通过插件机制实现自己的交换机
#### 扩展性：多个rabbitMQ节点可以组成一个集群，可以动态扩展集群中节点
#### 高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点问题出现情况仍可以使用
#### 多种协议：除了支持原生AMQP协议，还支持STOMP，MQTT等多种协议，中间件协议
#### 多语言客户端：支持多语言
#### 管理界面：用户管理界面
#### 令插件机制：许多插件，多方面进行扩展，也可以编写插件

### AMQP是什么？
#### RabbitMQ就是AMQP协议的Erlang的实现AMQP的模型架构和RabiitMQ的模型架构是一样的，生产者将消息发送给交换机，交换机和队列绑定 默认支持AMQP 0-9-1
### AMQP协议3层
#### Module Layer：协议最高层：主要定义客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑
#### Session Layer：中间层，主要负责客户端命令发送给服务器，再将服务器应答返回给客户端，提供可靠性同步机制和错误处理
#### Transport Layer：最底层，主要传输二进制数据流，提供帧的处理，信道复用，错误检测和数据表示等

### AMQP模型的几大组件
#### 交换机(Exchange)：消息代理服务器中用于把消息路由到队列的组件
#### 队列(Queue)：用来存储消息的数据结构，位于硬盘或内存
#### 绑定(Binding)：一套规则，告知交换机消息应该将消息投递给哪个队列

### 生产者和消费者
#### 生产者：消息生产者，消息包括(消息题-payload，标签-label)
#### 消费者：消息者连接到RabbitMQ服务器，并订阅到队列，消费消息时只消费消息体，丢弃标签

### Broker服务节点，Queue队列，Exchange交换机
#### Broker可以看做RabbitMQ的服务节点，一般情况下一个Broker可以看做一个RabbitMQ服务器
#### Queue：RabbitMQ的内部对象，用于存储消息，多个消费者可以订阅统一队列，这是队列的消息会被平摊给多个消费者进行处理
#### Exchange：生产者将消息发送到交换机，由交换机将消息路由到一个或多个队列中，当路由不到时，或返回给生产者或直接丢弃

### 消息队列的优缺点
#### 优点：解藕，异步，削峰
#### 缺点：系统可用性降低，越多的外部依赖，越容易挂掉，消费重复，消息丢失，消息传递的顺序性，数据的一致性等

### 如何保证消息的可靠性
#### 生产者到MQ；事务机制和confirm机制，两者互斥
#### MQ：持久化，集群，普通模式，镜像模式
#### MQ到消费者：basicAck机制，死信队列，消息补偿机制

### rabbitMQ如何防止消息丢失
#### 生产者没有成功把消息发到MQ
##### 丢失原因：网络传输不稳定，MQ没有成功接受消息，生产者以为MQ接受消息，不会重复发送，导致丢失
##### 解决方式：事务机制和confirm机制(常用)
#### MQ接收消息之后丢失消息
##### 丢失原因：接收的消息存在内存当中，没有消费完，当MQ宕机重启时，内存消息丢失
##### 解决方式：开启MQ持久化，持久化到磁盘，结合confirm机制，才会回调生产者的借口返回ack消息，否则都算失败，生产者重新发送
#### 消费者丢失消息
##### 丢失原因：消息成功发送给消费者后，MQ的ack机制会回调成功，表面消息发送成功，消息没有处理完时宕机，该消息丢失
##### 解决方式：必须关闭ack，可以通过api来调用，在程序完成时通过api调用ack确认

### rabbitMQ如何防止重复消费
#### 重复原因：消费完毕时会发送ack确认消息给队列，由于网络传输等故障，确认消息没有传输到消息队列，再次分发消息给消费者
#### 解决方式：保证消息唯一性，就算多次传输，不要让多次消费带来影响，保证消息等幂性
#### 消息产生时，MQ内部针对每条消息生成一个inner-msg-id，作为去重等依据，避免重复进入队列
#### 消费消息时，要求消息中必须有一个bizid，作为去重等依据，避免同一消息多次消费