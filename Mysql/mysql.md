### Mysql Basics

#### Mysql架构
 mysql架构可以在多种不同场景作用，主要体现在存储引擎架构上，`插件式存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离`，根据业务选择
 - 连接层：最上层是一些客户端和连接服务，主要完成类似连接处理，授权认证，相关安全方案，基于SSL安全链接
 - 服务层：核心服务功能，包括查询解析、分析、优化、缓存及内置函数，跨存储引擎包括触发器、存储过程、视图等
 - 引擎层：存储引擎真正负责mysql中数据的存储和提取，服务器通过API与存储引擎进行通信
 - 存储层：主要将数据存储在运行于该设备的文件系统上，并完成与存储引擎的交互
##### Mysql查询流程
 客户端请求 -> 连接器(验证用户身份，给予权限) -> 查询缓存(有则返回) -> 分析器(对SQL词法语法分析) -> 优化器(对执行sql选择最佳执行方案) -> 执行器(先看用户权限，使用引擎接口) -> 引擎层获取数据返回(开启缓存则缓存查询结果)

#### Mysql引擎
 常见存储引擎：InnoDB、MyISAM、Memory、NDB
 InnoDB是Mysql默认存储引擎，支持事务、行级锁定和外键
 MyISAM物理文件结构：
 - .frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息
 - .MYD：存储表数据
 - .MYI：存储表索引相关信息
 InnoDB物理文件结构：
 - .frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息
 - .ibd/.ibdata：都是存放InnoDB数据的文件，因为InnoDB的数据存储方式通过配置来决定`共享表空间`还是`独享表空间`
 InnoDB和MyISAM引擎区别：
 - InnoDB支持事务，成为mysql默认引擎重要原因之一
 - InnoDB支持外键，包含外键的转表会失败
 - InnoDB是聚簇索引，因此必须要有主键，聚簇索引文件存放在主键索引的叶子节点上，通过主键索引效率高，但是辅助索引需要两次查询，先查询主键，再通过主键查询数据，主键不宜过大，导致其他索引过大
 - InnoDB不保存表的具体行数，执行`select count(*)...`扫描全表，MyISAM用变量保存整表行数
 - InnoDB最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁，更新语句会锁柱整张表，导致阻塞
 `一张表，里面有ID自增主键，当insert了17条记录之后，删除第15，16，17条记录，重启Mysql，再insert，该ID为`
 - MyISAM类型：18，MyISAM会把自增最大ID记录到数据文件中，重启不会丢失
 - InnoDB类型：15，InnoDB只是把最大ID记录到内存中，重启会对表进行OPTION操作，导致丢失

#### Mysql数据类型
 `CHAR和VARCHAR区别`
 - char是固定长度，varchar长度可变
 - char按规定长度分配存储空间，varchar根据实际分配空间
 - 相同点：超过最大长度限制后，字符串会被截断
 - 不同点：char存储上限为255字节，char存储时会截断尾部空格
 char适合存储很短、长度固定的字符串，例如MD5值
 `列的字符串类型可以是什么`
 - 字符串类型是：SET BLOB ENUM CHAR TEXT VARCHAR
 `BLOB和TEXT区别`
 - BLOB是二进制对象，可容纳可变数量数据，四种类型：BLOB TINYBLOB BLOB MEDIUMBLOB LONGBLOB
 - TEXT是一个不区分大小写的BLOB，四种类型：TINYTEXT TEXT MEDIUMTEXT LONGTEXT
 BLOB保存二进制数据，TEXT保存字符串数据

#### Mysql索引
  [索引参考](https://www.cnblogs.com/kungfupanda/p/12776674.html)
 索引(index)是帮助Mysql高效获取数据的`数据结构`
 简单理解为`排好序快速查找的数据结构`，数据本身之外，数据库还维护一个满足特定查找算法的数据结构
 索引本身也很大，不可能全部存储在内存中，一般以索引文件形式存储在磁盘上
 平常默认索引就是B+树(多路搜索树，不一定是二叉树)结构组织的索引，其中：聚集索引、次要索引，覆盖索引，复合索引、前缀索引，唯一索引默认都是使用B+树索引，此外还有哈希索引等
 优势：
 - 提高数据检索效率，降低数据库IO成本
 - 降低数据排序成本，降低CPU消耗
 劣势：
 - 索引也是一张表，保存主键和索引字段，并指向实体表的记录，所以也需要内存
 - 降低更新表的速度，更新时不仅保存数据，还要保存索引文件每次更新索引字段
 索引分类
 ##### 数据结构角度：
 - B+树索引
 - Hash索引
 - Full-Text全文索引
 - R-tree索引(空间索引)
 ##### 物理存储角度：
 - 聚簇索引
 - 非聚簇索引(辅助索引)
   都是B+树结构
 ##### 逻辑角度：
 - 主键索引：特殊的唯一索引，不允许有空值
 - 普通索引或单列索引：每个索引只包含单个列，一个表可以多个单列索引
 - 多列索引(复合索引、联合索引)：多个字段创建的索引，查询中使用创建索引的第一个字段，索引才会被使用，最左原则
 - 唯一索引或非唯一索引
 - 空间索引：是对空间数据类型字段建立的索引：GEOMETRY POINT LINESTRING POLYGON
   Mysql必须使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引，空间索引列需声明为NOT NULL
   空间索引只能在存储引擎为MYISAM表创建
  索引实在存储引擎层面实现的，并不是所有存储引擎都支持所有的索引类型，实现和行为有差异
  ##### B+树和B树的区别
  - B+树非叶子节点只包含导航信息，不包含实际的值，所有的叶子节点和相连的节点都使用链表相连，便于区间查找和遍历
  B+树优点在于
  - IO次数更少：内部节点上不包含数据信息，因此能够存放更多的key，数据存放更加紧密，更好的空间局部性，访问叶子关联数据也有更好的缓存命中率
  - 遍历更加方便：B+树的叶子节点都是相连的，因此整棵树只需要一次线性遍历即可，便于区间查找和搜索
  B树优点
  - 每个节点包含key和value，经常访问的元素可能离根节点更近，更迅速
   `为什么Mysql索引中用B+树，不用B树，为什么不用Hash索引`
  - B+树磁盘读写代价更低：B+树内部节点没有关键字具体信息指针，因此内部节点相对B树更小，读入内存的需要查找的关键字也就多，相对IO读写次数降低
  - B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的节点，而只是叶子节点的关键字索引，关键字查询路径长度相同，数据查询效率相当
  - B+树更便于遍历：B+树数据都存储在叶子节点，分支节点为索引，方便扫库，B树节点存储着数据，需遍历按序来扫
  - B+树更适合基于范围的查询：B树再提高IO性能的同时并没有解决元素遍历的效率低下的问题，B+只需要遍历叶子节点就可以实现遍历整棵树的遍历，而且再数据库中基于范围查询是非常频繁的
##### MyISAM主键索引与辅助索引的结构
 MyISAM引擎的索引文件和数据文件是分离的，`MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际数据，而是数据地址`
 索引文件和数据文件分离，索引称为`非聚簇索引`
##### InnoDB主键索引与辅助索引的结构
 `InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际数据记录`，或说InnoDB数据文件本身就是主键索引文件，称为`聚簇索引`
##### 主键索引
 InnoDB索引和数据存入同一个.ibd文件中，因此它的索引结构是在同一个树节点中同时存放索引和数据
 在InnoDB中，索引分叶子节点和非叶子节点，非叶子节点如目录，单独存放在索引段，叶子节点则是按顺序排序，在数据段中，数据文件可以按照表切分(开启innodb_file_per_table)，切分后存放在xxx.ibd，默认不切分存放在xxx.ibdata
##### 辅助(非主键)索引
 辅助索引与主键索引差别在最底层叶子节点数据行，辅助索引按照ASCII码进行排序
 意味着对字段进行条件搜索需要步骤
 - 在辅助索引上检索字段，到达其叶子节点获取对应的主键
 - 使用主键在主索引上再进行对应的检索操作
 这就是所谓的`回表查询`
##### InnoDB索引结构需要注意的点
 - 数据文件本身就是索引文件
 - 表数据文件本身就是按B+树组织的一个索引结构文件
 - 聚簇索引中叶子节点包含了完整的数据记录
 - InnoDB表必须要有主键，并且推荐使用整型自增主键
 索引与数据是共同存储的，不管主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到对应数据，如果我们在设计表结构时没有`显式指定索引列`的话，Mysql会从表中选择数据不重复的列建立索引，如果没有符合的列，则Mysql自动为InnoDB生成一个隐含字段作为主键，并且长度为6个字节，类型为整型
##### 为什么推荐使用整型自增主键而不是选择UUID
 - UUID是字符串，比整型消耗更多存储空间
 - 在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快
 - 自增的整型索引在磁盘中会连续存储，在读取一页的数据时也是连续，UUID是随机产生的。读取上下的数据存储是分散的，不适合范围查询
 - 在插入或删除数据时，整型自增主键会在叶子节点的末尾建立新的叶子节点，`不会破坏左侧子树的结构`，UUID容易出现这种情况，B+树为了维持自身特性，有可能进行结构重构，消耗更多时间
##### Hash索引
 - 主要通过Hash算法(直接定址法、平方取中法、折叠法、除数取余法、随机数法)，将数据库字段转换为定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置，如果发生Hash碰撞，则在对应Hash键下以链表形式存储
 - 检索算法：在检索查询时，就再次对待查关键字执行相同的Hash算法，得到Hash值，到对应Hash表对应位置去除数据，如果发生碰撞则需要在取值时进行筛选
###### 为什么不用Hash作为索引
 - 区间值难找，因为单个值计算很快，需遍历全部Hash节点
 - 排序难，压缩算法，大小值可能落在一个Hash桶里，容易产生Hash冲突 
##### FULL-TEXT全文索引
 - 全文索引也是MyISAM的一种特殊索引类型，InnoDB从5.6支持
 - 它用于替代效率较低的LIKE模糊匹配查询，而且可以通过多个字段组合的全文索引一次性全模糊匹配多个字段
 - 同样使用B树存放索引，但使用特定算法，将字段数据分割后再进行索引(4个字节分割一次)
##### 需创建索引的情况
 - 主键自动建立唯一索引
 - 频繁作为查询条件的字段
 - 查询中与其他表关联的字段，外键关系建立索引
 - 单键/组合索引的选择问题，高并发下倾向创建组合索引
 - 查询中排序的字段，排序字段通过索引访问大幅度提高排序速度
 - 查询中统计或分组字段
##### 不需创建索引情况
 - 表记录太少
 - 经常增删改查
 - 数据重复且分布均匀表字段
 - 频繁更新的字段(加重IO负担)
 - where条件用不到的字段
##### Mysql高效索引
 覆盖索引(covering index)，不需要回表操作
 - 就是select的数据列只用从索引中就能得到，不必读取行数据，`查询列要被所建索引覆盖`
 - 索引高效找到行的一个方法，一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行，当能通过读取索引就能得到想要的数据，一个索引包含(覆盖)满足查询结果的数据就是覆盖索引
 - 判断标准：使用explain，通过extra列判断，对于覆盖索引查询显示`using index`，Mysql查询优化器在执行查询前会决定是否有覆盖查询

#### Mysql查询
 `count(*) count(1) count(filed) 区别`
 - 执行效果
   - count(*)包括所有列，相当于行数，在统计结果时候，不会忽略列值为NULL
   - count(1)包括所有列，用1代表代码行，在统计结果时候，不会忽略列值为NULL
   - count(filed)，只包括那一列，会忽略列值为空的计数
 - 执行效率
   - filed为主键，count(filed) > count(1)
   - filed不为主键，count(1) > count(filed)
   - 如果表多个列并且没有主键，则count(1) > count(*)
   - 如果有主键,count(filed)最优
   - 如果表只有一个字段 count(*)最优
 `Mysql中in和exists的区别`
  - exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exits里的条件语句能够返回记录行时，条件就为真，返回当前loop到这条记录，exists的条件就像一个bool条件，当能够返回结果集为true，不能返回结果集为false
  - in：in查询相对与多个or条件的叠加
  如果查询的两个表大小相当，那么用in和exists差别不大
  一个是大表，则子查询用exists，小表子查询用in
  `UNION和UNION ALL的区别`
  都是将两个结果集合并为一个，两个要联合的sql语句 字段个数必须一样，而且字段类型要一致
  - UNION再进行表连接后会筛选掉重复的数据记录(效率较低)，而UNION ALL则不会去掉重复的数据记录
  - UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并返回

#### Mysql事务
##### ACID-事务基本要素
 - Atomicity原子性：整个事务的所有操作，要么全部完成，要么全部不完成，发生错误回滚到事务之前状态
 - Consistency一致性：在事务开始和结束后，数据库的完整性约束没有被破坏
 - Isolation隔离性：事务之间互不干扰，事务内部操作及使用数据对其他并发事务是隔离的
 - Durability持久性：在事务完成之后，该事务所对数据库的所做更改便持久保存在数据库中
##### 并发事务处理带来的问题
 - 更新丢失(Lost Update)：事务AB选择同一行，然后基于最初选定的值更新该行，由于两个事务彼此不知，发生丢失更新
 - 脏读(Dirty Reads)：事务A读取事务B更新的数据，然后事务B回滚操作，那么事务A读取的就是脏数据
 - 不可重复读(Non-Repeatable Reads)：事务A多次读取同一数据，事务B在事务A多次读取的过程更新提交，导致多次读取不一致
 - 幻读(Phantom Reads)：类似不可重复读，在事务A读取时，事务B插入数据，在随后查询中，事务A发现不存在的记录
 幻读和不可重复读的区别：
 不可重复读重点是`修改`，幻读重点在于`新增或删除` 
##### 并发事务处理带来的问题及解决方案
 - 更新丢失：通常应该完全避免的，防止更新丢失并不能单靠数据库事务控制器解决，需要应用程序对更新数据`加锁`，应是应用责任
 - 脏读、不可重复读、幻读：都是数据库一致性问题，必须由数据库提供一定的事务隔离机制解决
   - 加锁：在读取数据前加锁，阻止其他事务对数据进行修改
   - 数据多版本并发控制(MultiVersion Concurrency Control 简称MVCC或MCC)，不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照(Snapshot)，并用快照提供一定级别的一致性读取，用户角度来看，是数据库可以提供一个数据多个版本
##### 事务隔离级别
 事务隔离级别由低到高
 - 读未提交：最低隔离级别，允许读取尚未提交的数据变更，可能导致`脏读、幻读、不可重复读`
 - 读已提交：允许读取并发事务已提交的数据，可阻止脏读，可导致`幻读、不可重复读`
 - 可重复读(默认)：对同一字段多次读取结果都是一致的，除非数据都是被本身事务自己修改，可阻止脏读和不可重读夫，可导致`幻读`
 - 可串行化：最高隔离级别，完全服从ACID，所有事务逐个执行，事务之间不产生干扰
 查看事务隔离级别：`show variables like 'tx_isolation'`
 事务隔离越严格，并发副作用越小，代价越大，串行化与并发矛盾，根据应用决定，对于不敏感更关系并发访问能力
##### MVCC多版本并发控制
 Mysql大多数事务型存储引擎都不是简单行级锁，基于提升并发性考虑，各实现机制不同
 MVCC是行级锁的一个变种，很多情况避免加锁的操作，因此开销更低，大都实现非阻塞读操作，写操作也只是锁定必要行
 MVCC实现都是通过某个时间点的快照实现，每个事务看到的数据是一致
 典型的MVCC实现方式：分为 `乐观并发控制` `悲观并发控制`
 可重复读隔离级别下MVCC工作方式：
 - SELECT
   - InnoDB根据以下条件检查每行记录：
      - 只查找版本早于当前事务版本的数据行，保证事务读取的行是在事务开始之前存在或是事务自身修改过的
      - 行删除的版本号要么未定义，要么大于当前事务版本号，保证事务读取到的行在事务开始之前未被删除
      只有符合条件才会被查询
 - INSERT：InnoDB为新插入的每一行保存当前版本号
 - DELETE：InnoDB为删除的每一行保存当前版本号
 - UPDATE：InnoDB为插入的一行新纪录保存当前版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识
##### 事务日志
 InnoDB使用日志来减少提交事务时的开销，日志记录事务，则无须在每个事务提交时把缓冲池的脏块刷新`flush`到磁盘
 事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机IO
 随机IO比顺序IO昂贵，因为IO请求需要时间把磁头移到正确位置，待磁盘读出需要的部分，再转到开始位置
 日志把随机IO变成顺序IO，一旦日志安全写到磁盘，事务就持久化，即使断电也能重放日志并恢复已提交的事务
 事务日志帮助提高事务效率：
 - 使用日志时，在修改表时只需要修改其内存拷贝，再把该行为记录到持久在日志，不用每次都将修改持久到磁盘
 - 日志采用的时追加方式，写日志的操作是磁盘上一小块区域内的顺序IO，而不是随机IO需要多处移动磁头
 - 日志持久后，内存中被修改的数据在后台可以慢慢刷回到磁盘
 - 如果数据修改已经记录到日志并持久化，但数据未写入磁盘，系统崩溃重启后能够恢复一部分数据
 统称为`预写式日志(Write-Ahead Logging)`，修改需要写两次磁盘
##### 事务的实现
 事务的实现基于不同的存储引擎(InnoDB和NDB)
 事务的实现就是如何实现ACID特性
 事务的隔离性通过锁实现，而事务原子性、一致性和持久性则是通过事务日志实现
 `事务如何通过日志来实现`
 事务日志包括：`重做日志redo和回滚日志undo`